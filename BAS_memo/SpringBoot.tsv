項目	昔のJava Webアプリ（地獄）	Spring Bootでやると（天国）
設定ファイル	30個くらいXML設定ファイル書く	ほぼゼロ（自動設定）
Tomcat	自分でインストール・起動	内蔵Tomcatが勝手に起動
依存ライブラリ	1つずつ探して手動追加	1行書くだけで全部自動取得
起動方法	mainメソッドすら書かない	1つのmainクラスだけでアプリ起動
		
		
		
BTPでSpring Bootが超重要な理由		
やりたいこと	Spring Bootがやってくれること	
REST API作りたい	5行で完成	
データベース接続したい	application.ymlに4行書くだけで自動接続	
BTPにデプロイしたい	mvn package → cf push で即本番	
ローカルですぐ試したい	mvn spring-boot:run で0.5秒で起動	
		
application.yaml	Spring Boot の設定を外出しするためのメインファイル	
（application.yml）	・ポート番号などサーバ設定	
	・DB接続情報（URL・ユーザー名 など）	
	・ログレベル	
	・自作の設定値（例：自分で決めた my.app.xxx）	
	等々	
	配置：src/main/resources/application.yaml	
	同じ内容を application.properties で書くこともできる	
		
	環境ごとに設定を分けたいときは、application-{profile}.yaml　という名前が使える。	
	例：application-cloud.yaml	
		
		
		
		
アノテーション		
		
DI / コンポーネント関連		
@Configuration	「このクラスは設定を書くクラスですよ」と Spring に教えるためのマーク	
	@Configuration が付いたクラスの中の	
	@Bean が付いたメソッドを読んで、	
	その戻り値を Spring が管理するオブジェクト（Bean）として登録 します。	
		
@Bean	このメソッドが返したオブジェクトを、Spring の“部品（Bean）”として登録するためのマーク	
	@Bean	
	public Job job(JobRepository jobRepository, Step personImportStep) {	
	    return new JobBuilder("personImportJob", jobRepository)	
	            .start(personImportStep)	
	            .incrementer(new RunIdIncrementer())	
	            .build();	
	}	
	このメソッドを実行してできた Job オブジェクトを	
	Spring コンテナに 1個だけ作って保管しておいて	
	他のクラスから @Autowired Job job; などで 使えるようにする	
		
@Component	このクラスを「Spring が管理する部品（Bean）」として登録して、@Autowired などで注入できるようにする。	
@Service	@Component の一種で、「ビジネスロジックを書くサービスクラスだよ」と Spring に教える	
@Repository	@Component の一種で、「DBアクセスをするクラスだよ」と Spring に教える	
@Mapper	MyBatis のマッパーとして登録し、SQL とメソッドを紐づけてくれる。	
@Autowired	Spring に「ここに他の Bean を自動で注入して（DIして）」とお願いする	
@Qualifier	同じ型の Bean が複数あるとき、「この名前の Bean を注入して」と指定する	
		
JPA / エンティティ関連		
@Entity	このクラスは JPA で管理する「エンティティ（テーブルの1行に対応するクラス）」ですよ、と宣言する。	
@Table	どのテーブルと対応させるかを指定する	
@Id	このフィールドがテーブルの「主キー（ID）」です、と JPA に教える。	
@GeneratedValue	ID を DB や自動シーケンスで自動採番してもらう設定（自分で値をセットしなくてよくなる）	
@Column	このフィールドがテーブルのどのカラムと対応するか、詳細設定（カラム名、長さ、NULL許可など）を書く	
		
Lombok 関連		
@Data	getter/setter, toString, equals, hashCode, コンストラクタなどを自動生成してくれる（ボイラープレート削減）	
@Slf4j	log.info(...) などで使える log フィールド（SLF4Jロガー）を自動で生やしてくれる	
		
Spring 設定・値注入		
@EnableTransactionManagement	@Transactional などのトランザクション管理を有効にするスイッチ	
@Value	application.yaml などの設定値（プロパティ）を、そのフィールドに注入してくれる。	
		
Spring Batch 関連		
@StepScope	その Bean を「ステップ実行中だけ有効なスコープ」で管理し、ジョブパラメータなどを注入しやすくする。	
	ステップを実行するときに、その都度つくり直される Bean にする	
		
	普通の @Component や @Bean の Bean は	
	アプリ起動時に 1回だけ 作られてずっと同じインスタンスが使われます（シングルトン）	
		
	@StepScope を付けると、その Bean は：	
	・ステップ開始時に初めて生成される	
	・ステップが終わると捨てられる	
	・Bean の中で @Value("#{jobParameters['xxx']}") みたいにジョブパラメータを安全に受け取れる	
		
	とりあえず、Reader / Processor / Writerには必ず付ける！	
		
Java 標準		
@Override	親クラスやインタフェースのメソッドを正しくオーバーライドしていることをコンパイラにチェックしてもらう	
		
		
		
Spring Boot は		
スキーマ用: classpath:schema.sql		
データ用: classpath:data.sql		
という「デフォルトの場所」を自動で探しに行きます		

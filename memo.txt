
■PoweerShell

<インストール/アップデート>
winget search Microsoft.PowerShell


■Gemini CLI
https://github.com/google-gemini/gemini-cli

<インストール/アップデート>
npm install -g @google/gemini-cli@latest



■Codex CLI
<インストール/アップデート>
npm install -g @openai/codex@latest

<環境構築>
1.WSL2を入れる
2.WSLからnode.js、codexを入れる

<起動方法>
1.PowerShellを管理者権限で開く
2.wsl
3.codex

<バージョン確認>
codex --version

<Tips>
- リポジトリにAGENTS.mdを入れておくとよいらしい。
  そんでもって、指示する前に以下を指示する。
  このディレクトリの AGENTS.md を読んで、記載のルールに従ってください。以後は日本語で説明して。指示があるまではファイルの更新は絶対にしないでください。

  ソースを読んで仕様を理解して、仕様の概要をAGENTS.mdに記載してください。
  ver1.0.6の仕様を追記しましたので、対応をお願いいたします。前バージョンのmdファイルは「AGENTS__old_1.0.5.md」です。
  AGENTS.mdの仕様を全て実装して。
  実装前に疑問点があれば確認してから実装を開始して。


  以下のタスクを、**5行以内で**、**最もシンプルな方法で**実装してください。
  - クラスや関数は必要最小限に。
  - コメント、エラーハンドリング、拡張性は一切不要。
  - 余計な処理や最適化は絶対に追加しない。
  - 動けばOK。


■ステップバイステップ
・ステップバイステップとは各ステップを一気に述べるのではなく、1ステップを提示→そのステップをクリアするまで私とやりとりしてクリアしたら次のステップに進む・・を繰り返すこと。
・1つのステップの中でやることが多すぎないようにすること。 ステップバイステップと指示しているので、1つのステップ内でも1つずつ進めること。


■WSL2
# pwdの結果をクリップボードにコピーする

pwd | clip.exe                           Linuxのパス形式でコピー
wslpath -w "$(pwd)" | clip.exe           Windowsのパス形式でコピー



■Visual Studio Community
#起動できなくなったとき：
1. %ProgramFiles(x86)%\Microsoft Visual Studio\Installer\InstallCleanup.exe を管理者権限で実行。
2. コマンド: InstallCleanup.exe -i 17（17 は VS2022 を指定）。
3. PC を再起動後、再インストール。

■Base32で使用される文字 (32文字。A-Z 2-7)
ABCDEFGHIJKLMNOPQRSTUVWXYZ234567


■
アップロードした文字列の画像をテキストにしてください。
ちなみに文字列のフォントはConsolasで、使用している文字種はBase32 + ハイフンのみです。（全て半角文字）



■Maven

# フェーズの順序
generate-sources → generate-resources → compile → test → package


# ビルド成果物を消して、最初からビルドして成果物をローカルリポジトリ（~/.m2/repository）に登録する （テストはスキップ）
mvn clean install

# ビルド  ※targetの下にjarが出来る
mvn clean package

# ビルド （テストはスキップ）
mvn clean package -DskipTests

# Springを起動
mvn spring-boot:run 

# Springを起動（テストはスキップ、ログ少なめ（-q））
mvn -q -DskipTests spring-boot:run

# Springを起動（テストはスキップ、ログ少なめ（-q）、プロジェクト指定（-pl））
mvn -pl job-01 -q -DskipTests spring-boot:run

# ライブラリのバージョン確認。以下はSpring Batchの例
mvn dependency:tree | grep spring-batch-core

# ターミナルのエンコードをUTF-8にする（pom.xmlを修正）
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>

            <!-- これを追加 >> -->

            <configuration>
                <jvmArguments>-Dsun.stdout.encoding=UTF-8 -Dfile.encoding=UTF-8</jvmArguments>
            </configuration>

            <!-- これを追加 << -->

        </plugin>
    </plugins>
</build>


# JARの中にファイルがあるか確認。
jar tf job-01/target/job-01-0.0.1-SNAPSHOT.jar | grep messages.properties

# 以下のような結果が出れば存在する
BOOT-INF/classes/messages.properties


# JARの中からpom.propertiesがあるか確認（①）
jar tf <JARファイル> | grep -E '^META-INF/maven/.+/pom\.properties$' || echo "pom.properties が見つかりません"

# pom.propertiesがあれば、groupId, artifactId, versionを確認する
unzip -p <JARファイル> <①の結果>

# JARから完全修飾クラス名を確認する
jar tf <JARファイル> \
 | grep '\.class$' \
 | grep -v '^META-INF/' \
 | sed 's#/#.#g; s#\.class$##'




## import文（パッケージ）が解決される仕組み

ポイントは「エディタが直接 `javac` でコンパイルして判断しているわけではない」という点です。

1. Java Language Server（JDT系） が、Javaファイルを読み取って「どのクラスが見えるか（クラスパス）」を作る
   Java用の解析サーバ（Language Server）が裏で動きます。

2. Mavenの `pom.xml` を読み、依存関係を解決して クラスパスに載せる

   Mavenが落としてきたjarは基本 `~/.m2/repository` に置かれます
   Language Serverは、そのjar群も含めて「参照できる一覧」を作り、importの解決・補完・赤線表示をします。


## 「正しいimportなのに赤くなる」主な原因（よくある）

1. Language Serverのキャッシュが古い/壊れた
   → まれに import が解決できない “見かけのエラー” になります。

2. pom.xml更新後の“再読み込み（プロジェクト更新）”が追いついてない
   → `pom.xml` 右クリックの Reload Project で直ることがあります。

3. 依存jarがまだ落ちてない/途中で失敗（プロキシ・ネットワーク・一時エラーなど）
   → Maven的には取れてないので、Language Serverも解決できません。

4. マルチモジュール/生成コード がうまく認識されてない
   → “正しいはず” でも、エディタ側のプロジェクト認識がズレて赤くなることがあります。

## まず試す「安全で効く」手順（BAS/VS Code共通）

* `pom.xml` 右クリック → Reload Project
* コマンドパレット（Ctrl+Shift+P）で Java: Clean Java Language Server Workspace（依存の作り直し）
* それでもダメなら （Ctrl+Shift+P）で、Developer: Reload Window（画面ごと再読み込み）










# GitHub Packages（Maven）にJARを公開して、別プロジェクトから依存で使う手順

## 前提

* 公開先：GitHub Packages（Maven Registry）
* 例の座標（JARファイルA）：`com.example.batch:job-common:0.0.1-SNAPSHOT`
* 公開先リポジトリ：`mtk57/job-common1`
* GitHub Packages の Maven URL：`https://maven.pkg.github.com/OWNER/REPO`

---

## 1. 提供側（JARを公開する側：job-common1）

### 1-1. `pom.xml` に公開先（distributionManagement）を追加

`job-common1/pom.xml` に追加（`</project>` の前など）：

```xml
<distributionManagement>
  <repository>
    <id>github</id>
    <url>https://maven.pkg.github.com/mtk57/job-common1</url>
  </repository>
</distributionManagement>
```

`mvn deploy` のアップロード先を GitHub Packages にするための設定。 

### 1-2. GitHub のトークン(PAT)を用意

* 公開（deploy）するなら `write:packages`
* 取得（依存として使う）もするなら `read:packages` 

### 1-3. `~/.m2/settings.xml` に認証情報を追加

**pom.xml にトークンは書かない**（ローカルの settings に書く）。

```xml
<settings>
  <servers>
    <server>
      <id>github</id>
      <username>mtk57</username>
      <password>YOUR_TOKEN</password>
    </server>
  </servers>
</settings>
```

※ `<id>github</id>` は、`distributionManagement` の `<id>` と一致させる。

### 1-4. deploy する

```bash
mvn -DskipTests clean deploy
```

### 1-5. GitHub の Packages に出ていることを確認

GitHub の `mtk57/job-common1` リポジトリの **Packages** に `job-common` が表示されればOK。

---

## 2. 利用側（別プロジェクトから依存として使う側）

### 2-1. 親POMに GitHub Packages を repositories として追加

親 `pom.xml` に追加：

```xml
<repositories>
  <repository>
    <id>github</id>
    <url>https://maven.pkg.github.com/mtk57/job-common1</url>
    <snapshots>
      <enabled>true</enabled>
    </snapshots>
  </repository>
</repositories>
```

※ `0.0.1-SNAPSHOT` を取るので snapshots を有効化。 

### 2-2. version は親POMの `dependencyManagement` に寄せる

親 `pom.xml`：

```xml
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>com.example.batch</groupId>
      <artifactId>job-common</artifactId>
      <version>0.0.1-SNAPSHOT</version>
    </dependency>
  </dependencies>
</dependencyManagement>
```

* 子POMで version を省略したい時の標準的な方法。 

### 2-3. 子POMでは dependency を version なしで書く

例：`job-01/pom.xml`

```xml
<dependency>
  <groupId>com.example.batch</groupId>
  <artifactId>job-common</artifactId>
</dependency>
```

---

## 3. 注意（マルチモジュール構成）

* 親POMの `<modules>` に書いたモジュールは **実フォルダが必要**。
* 今回のように **job-common をGitHubから取る運用**なら、親の `<modules>` から `job-common` を外す（`job-01` だけ残す）。

---

## 4. 動作確認コマンド

### 4-1. 依存解決できるか確認

```bash
mvn -pl job-01 -am -U dependency:resolve
```

ログに `Downloaded from github: ... job-common-...jar` が出ればOK。

### 4-2. 通常ビルド（compile/test）確認

```bash
mvn -pl job-01 -am -U test
```

### 4-3. ローカルに落ちたJARの確認

```bash
ls -1 ~/.m2/repository/com/example/batch/job-common/0.0.1-SNAPSHOT/
```



















■H2   ※メモリ型のDB

# SpringBoot起動時のログに以下が出ていればH2に接続できている状態
HikariPool-1 - Added connection conn0: url=jdbc:h2:mem:testdb user=SA

JavaとH2の型 (代表的なもののみ)
String        → VARCHAR / CLOB
int           → INT
long          → BIGINT
BigDecimal    → DECIMAL
boolean       → BOOLEAN
LocalDate     → DATE
LocalDateTime → TIMESTAMP
byte[]        → BLOB / VARBINARY


■Linux

# 8080ポートを誰がListenしているか?
lsof -i :8080

# PIDのプロセスを落とす
kill -9 <PID>

# 全ファイル/フォルダを表示
ls -a

# フォルダをzipに
zip -r myproj.zip myproj -x '*/.git/*' '*/target/*' '*/node_modules/*' '*/mta_archives/*' '*/.vscode/*' '*/.gen/*'




■VS Code

# フォントサイズ
拡大：Ctrl + +
縮小：Ctrl + -
左の歯車 → Settings → Editor: Font Size

# mdファイルをプレビュー  (拡張入れなくもOK)
CTRL + SHIFT + V

# プロジェクトのコピー
cd ~/projects
cp -r src dst
→Mavenの場合、pom.xmlをartifactidを変える

# ファイル検索
画面中央上の虫眼鏡

# ファイル内検索
画面左の虫眼鏡

# BASリロード
Ctrl + Shift + P → "Developer: Reload Window"


■Git

rm -rf .git
git init
git add .
git commit -m "first commit"
git remote add origin https://github.com/mtk57/SoapServerTest2.git
git branch -M main        # GitHub側が main ブランチの場合
git push -u origin main

# clone
1.左のSource ControlのCHANGESの...からclone
2.githubのURLを入れる

git clone https://github.com/mtk57/BatchH2MyBatisTest2.git

# git管理対象をツリー表示
git ls-tree -r --name-only HEAD | tree --fromfile .


■Cloud Foundry/HANA Cloud

# HANA Cloud Central に行く手順 (BTP Cokckpit)
1.Instances and Subscriptions
2.SAP HANA Cloud
3.Go to Application


# SAP HANA Cloudを開始する手順
1.HANA Cloud Central → Instances
2.対象インスタンス行の Actions（…） を開く
3.Start


# HANA Cloud Central で接続元IPを許可する手順
1.HANA Cloud Central → Instances
2.対象インスタンス行の Actions（…） を開く
3.Manage Configuration をクリック
4.タブで Connections を開く 
5.Allowed connections（許可する接続）で、次のどちらかを選ぶ
  まず切り分けしたい → Allow all IP addresses（一時的） 
  きちんと制限したい → Allow specific IP addresses and IP ranges
  「Allow specific…」を選んだ場合、許可IP（またはCIDR）を追加
   例：203.0.113.45/32（1つのIPだけ許可）
6.Review / Save（保存）で確定 

HANA Cloud はデフォルトで “全IP拒否” なので、ここを設定しないと外部から基本つながりません。

BAS から接続する場合の注意（ここで詰まりやすい）
許可すべきIPが あなたのPCのグローバルIPではなく、BAS側の出口IP になることがあります。
BASから見える外向きIPを確認
curl -s https://api.ipify.org ; echo

ここで出たIPを /32 を付けて allowlist に入れるのが手早いです。




# SAP HANA Database Explorer
1.HANA Cloud Central → Instances
2.対象インスタンス行の Actions（…） を開く
3.SAP HANA Database Explorer
4.左の「+」でAdd Instance画面を開く
5.Instance Typeで HDI Containerを選ぶ
6.ログインするリンクするみたいなのをクリック












■SAP BTP BASのSpring BatchからH2コンソールを使う
1.pom.xmlに以下を追加。(H2はメモリDBなのでバッチのようにアプリが終わってしまう場合はTomCatを常時起動しておく必要がある)
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
  </dependency>

2.application.properties
  spring.main.web-application-type=servlet  # Webサーバとして起動する
  #spring.main.web-application-type=none    # Webサーバとして起動しない(バッチアプリはこれ)

  spring.h2.console.enabled=true                    # H2コンソールを有効
  spring.h2.console.path=/h2-console                # 後で出てくるURLに付けるパス
  spring.h2.console.settings.web-allow-others=true  # H2コンソールを外部からアクセス可能にするか否か

  spring.batch.job.enabled=false        # バッチジョブの自動起動有無。falseだとアプリが起動してもジョブは起動せずWebサーバだけが立ち上がる
                                        # 以下のようなログが出ていなければ自動起動は抑止されている
                                          JobLauncherApplicationRunner : Running default command line with: ...
                                          Job: [SimpleJob: [name=sampleDataJob]] launched with the following parameters: ...
  spring.profiles.active=local          # テスト用/本番用の切り替え
  #spring.profiles.active=cloud         # テスト用/本番用の切り替え

3.ビルドしてアプリを起動する
  ログに以下が出ていればOK
  Tomcat started on port 8080 (http) with context path '/'
  H2 console available at '/h2-console'.

4.Ctrl + Shift + P
  Ports: Preview
  8080
  →ブラウザで新しいタブが勝手に開く
  
5.開いたタブのURLの末尾に
  /h2-console
  →H2コンソールが開く

6.H2コンソールのJDBC URLを
  jdbc:h2:mem:testdb
  にして「Connect」

この方法だとバッチが最後まで走り切った状態のDBを覗くことになるので
バッチが走る前にDBを変更したい場合は、

7.以下のクラスを追加
package com.example.batch_h2_mybatis_chunk_test.web;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.JobParametersBuilder;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@Profile("local")
@RestController
public class JobRunController {

    private final JobLauncher jobLauncher;
    private final Job sampleDataJob;

    public JobRunController(JobLauncher jobLauncher, Job sampleDataJob) {
        this.jobLauncher = jobLauncher;
        this.sampleDataJob = sampleDataJob;
    }

    @GetMapping("/run-sample-job")
    public ResponseEntity<String> runJob() throws Exception {
        // ジョブパラメータに時刻を入れて、毎回別ジョブとみなしてもらう
        JobParameters params = new JobParametersBuilder()
                .addLong("runAt", Instant.now().toEpochMilli())
                .toJobParameters();

        jobLauncher.run(sampleDataJob, params);

        return ResponseEntity.ok("sampleDataJob started");
    }
}

8.ビルドして、手順3～6を実施

9.まだジョブは起動していないので、DBを変更しておく。

10.URLの/h2-console以降を
  /run-sample-job
  に変更
  →画面にsampleDataJob startedが出るのでジョブが開始される

11.元に戻すときは
   application.propertiesから以下をコメントアウト
   #spring.h2.console.enabled=true
   #spring.h2.console.path=/h2-console
   #spring.h2.console.settings.web-allow-others=true
   #spring.batch.job.enabled=false

   #spring.main.web-application-type=servlet
   spring.main.web-application-type=none



■Spring Batch

# Chunkのイメージ：

    list = []

    while (true) {
      in = reader.read()

      if (in == null) {
        if (list not empty) writer.write(list)   // 残りも出す
        break
      }

      out = processor.process(in)   // 変換後（別オブジェクトになることが多い）

      if (out != null) {            // null を返すと「その1件は捨てる」（filter）
        list.add(out)
      }

      if (list.size >= CHUNK_SIZE) {
        writer.write(list)
        commit()                    // ★ここがチャンクの肝（まとめて確定）
        list.clear()
      }
    }



TransientDataAccessException：一時的なDBエラーの親    ※DB系のリトライさせるならコレ


# MyBatisからHANA Cloud 接続

1.BTP CockpitでPlanが「hdi-shared(HDIコンテナ)」のインスタンスからサービスキーの情報（url, user, password, schema）を取得
2.Application.yamlのdatasourceに設定
spring:
  datasource:
    url: 'URL'
    username: 'ユーザー名'
    password: 'パスワード'
    driver-class-name: com.sap.db.jdbc.Driver
    hikari:
      connection-init-sql: 'SET SCHEMA "スキーマ"'



■ OAuth

# 仕組みの簡単な流れ（OAuth 2.0の場合）
1.ユーザーがアプリ（クライアント）で「Googleでログイン」を選択。
2.アプリがユーザーをGoogleの認可サーバーにリダイレクト。
3.ユーザーがGoogleでログインし、許可を与える（同意画面）。
4.Googleがアプリに「認可コード」を発行。
5.アプリがそのコードをアクセストークンに交換。
6.アプリがトークンを使ってGoogleのAPIにアクセス（ユーザーのデータ取得など）。


# XSUAAの流れ

## 登場人物：
・Browser（ユーザ）
・Approuter（入口。認証して、バックエンドへ中継）
・XSUAA（OAuthの認可サーバ）
・IdP（ログイン画面。IASや社内IdPなど）    ※Identity Provider
・CAPサービス（Node/Javaのバックエンド）

##シーケンス（初回アクセス）：   https://community.sap.com/t5/technology-blog-posts-by-members/approuter-and-xsuaa/ba-p/13515223
1.Browser → Approuter
  /odata/v4/... などにアクセス（まだログインしてない）

2.Approuter：JWT（Json Web Token）が無い/無効 → ログイン開始
  JWTが無いと判断すると、ユーザをログインへ誘導する（リダイレクト）。 

3.Approuter → XSUAA（/oauth/authorize）
  Authorization Code Grant を開始（response_type=code、redirect_uri など付き）。 

4.XSUAA → IdP → Browser
  XSUAAは（設定された）IdPのログインへ回し、ユーザが認証する。 

5.IdP → XSUAA → Browser（認可コード付きで戻す）
  認証が成功すると、XSUAAが 認可コード（authorization code） を発行して redirect_uri（=Approuter）へリダイレクト。 

6.Approuter → XSUAA（/oauth/token）
  受け取った  認可コード を使って、アクセストークン（JWT） を発行る。 

7.Approuter → CAPサービス
  Approuterは元のリクエストを再開し、JWTを付けてCAPへ転送（設定で forwardAuthToken を使うのが典型）。 

8.CAPサービス：JWTを検証 → ユーザ情報として扱う
  CAPは Authorization: Bearer <JWT> を受け取り、（XSUAAのバインド情報を使って）検証し、ユーザ/権限をリクエストに載せる。 



# サービスキー
・XSUAA：「誰が何を許可されるか」を制御するためのOAuthクライアントクレデンシャル。セキュリティ/認可に特化。
・HDIコンテナ：「HANAデータベースにどう接続するか」を提供するDB接続情報。データ永続化/デプロイに特化。

CAPプロジェクト：XSUAAは必須。HDIコンテナのサービスキーはバインディングで代用可能なので不要。
SpringBatchプロジェクト：JDBCでHANA Cloudにアクセスする場合はHDIコンテナのサービスキーが必要。ODataを使用する場合はXSUAAのサービスキーが必要。



# VCAP_SERVICES
SAP BTPのCloud Foundry環境で、アプリケーションにバインドされたサービスインスタンスの接続情報を自動的に渡すための環境変数

超簡単なイメージ：
・アプリ（Spring Batch、CAP Javaなど）をCloud Foundryにデプロイするとき、「このアプリはHANAとXSUAAを使いたい」とバインドしておきます。
・デプロイが完了し、アプリが起動すると、Cloud Foundryが自動でVCAP_SERVICESという名前の環境変数に、すべてのバインドされたサービスの接続情報をJSON形式で入れてくれます。
・アプリ側（Spring BootやCAPなど）はこのJSONを読み取って、自分でユーザー名やパスワードを書かなくてもデータベースやサービスに接続できるようになります。




■ BAS

# ポートフォワーディング
・BASでWebサーバ(Tomcatとか)が起動すると、localhost:8080とかなのでクライアントからは通常アクセスできないが、
  ポートフォワーディングするとBASが公開用URLを作成(これがいわゆるトンネル)するので、クライアントからそこにアクセスすると
  サーバ側のlocalhost:8080にクライアントからのリクエストを転送してくれる。






=========================================================================

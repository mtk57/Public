■Hello world								
cd /home/user/projects								
git clone https://github.com/devsuperior/hello-world-spring-batch.git								
cd hello-world-spring-batch								
mvn clean package -DskipTests								この Spring Batch プロジェクトのソースコードをコンパイルして、実行できる形（jar）にまとめる。ただしテストは省略
mvn spring-boot:run								この Spring Batch のアプリを、Spring Boot として実行する
								-e を付けると例外情報も出る
								
								
								
application.properties								
Spring Boot の設定ファイルで、キー=値形式でアプリの各種設定を書く場所です。環境に応じて外部化でき、起動時に自動で読み込まれます。								
このプロジェクトでは H2 の接続情報、Batchスキーマ初期化、MyBatisマッパー位置、H2コンソール有効化などをここで指定しています。								
 								
								
Job	バッチ全体の「シナリオ」							
								
	例：							
	CSV取込ステップ							
	→ 集計ステップ							
	→ 結果メール送信ステップ							
								
	こういう「一連の流れ」を 1つにまとめたものが Job							
								
	あなたのプロジェクトの personImportJob は							
	「personImportStep を1回実行するだけのジョブ」です。							
								
Step	Job を構成する1つ1つの「作業単位」							
								
	1つの Job の中に複数 Step を並べられる。							
								
	種類はざっくり2つ：							
	Tasklet ステップ（1回きりの処理）							
	チャンクステップ（Reader/Processor/Writer の繰り返し）							
								
	personImportStep は							
	「チャンク式で CSV→DB へ書き込むステップ」です。							
								
Reader	入力を読む係							
								
	どこから読むかは実装次第：							
	CSVファイル							
	DB							
	キュー　など							
								
	あなたのプロジェクトでは							
	FlatFileItemReader<PersonCsv> が							
	「CSVファイルを1行ずつ PersonCsv にして返す」Reader です。							
								
Processor	読んだデータを「加工・変換」する係							
								
	例：							
	型変換（文字列 → 日付/数値）							
	不正データの判定＆スキップ							
	複数項目から新しい値を計算（年齢など）							
								
	PersonProcessor は							
	生年月日文字列を LocalDate に変換							
	年齢を計算							
	PersonEntity に詰め替え							
	無効な日付なら null を返してスキップ							
	というロジックを担当しています。							
								
Writer	加工済みデータを書き出す係							
								
	出力先の例：							
	DB（INSERT/UPDATE）							
	ファイル							
	メッセージキュー　など							
								
	チャンク単位（例：5件ずつ）でまとめて書くのが特徴。							
								
	あなたのプロジェクトでは							
	MyBatisBatchItemWriter<PersonEntity> が							
	PersonMapper.insert() を呼んで							
	persons テーブルに INSERT する Writer							
	になっています。							
								
								
								
								
このプロジェクトに限った「クラスが動く順番」を、できるだけシンプルに書きます。								
								
## アプリ起動時（1回だけ）								
								
	1. **`SpringBatchChunkTestApplication.main()` が呼ばれる**							
	   * `SpringApplication.run(...)` を実行。							
								
	2. **Spring が各クラスを準備**							
	   * `@SpringBootApplication` によりコンポーネントスキャン。							
	   * `@Configuration` な							
	     * `BatchConfig`							
	     * `PersonImportStepConfig`							
	       などが読み込まれ、							
	   * その中の `@Bean` メソッドが呼ばれて							
	     * `Job`（`personImportJob`）							
	     * `Step`（`personImportStep`）							
	     * `ItemReader`							
	     * `PersonProcessor`							
	     * `ItemWriter`（MyBatisBatchItemWriter）							
	       などが **1個ずつ作られて登録** される。							
	   * `@MapperScan` によって `PersonMapper` も生成される。							
								
	ここまでは「設定を読むフェーズ」で、**まだCSV処理は走っていない**イメージです。							
								
## ジョブ実行時（データ件数に応じて繰り返し）								
								
	ジョブとして動き出してからの「1件のデータが通る流れ」はこうです。							
								
	### ① Step実行開始							
								
		* `personImportJob` の中で						
		  → **`personImportStep` がスタート**。						
								
	### ② Reader → Processor → Writer の順							
								
		チャンク処理の「1レコードあたり」の流れは：						
								
		1. **ItemReader（`FlatFileItemReader<PersonCsv>`）**						
			   * CSVファイルから1行読み込む					
			     → `PersonCsv` オブジェクト生成。					
								
		2. **ItemProcessor（`PersonProcessor`）**						
			   * `PersonCsv` を受け取る。					
			   * 生年月日文字列を `LocalDate` にパース。					
			   * 年齢を計算。					
			   * `PersonEntity` を作って返す。					
			   * パースに失敗したら `null` を返し、そのレコードはスキップ。					
								
		3. **ItemWriter（MyBatisBatchItemWriter + `PersonMapper`）**						
			   * `PersonProcessor` が返した `PersonEntity` をまとめて受け取る。					
			   * 内部で **`PersonMapper.insert(personEntity)` を繰り返し呼び出す**。					
			   * DB（`persons` テーブル）に INSERT。					
								
	### ③ チャンク単位のコミット							
		* 上の **②（Reader→Processor→Writer）を「最大5件」分まとめて1セット** として処理。						
		* 5件終わると、トランザクションを **コミット**。						
		* まだCSVに行が残っていれば、また						
		  > Reader → Processor → Writer（最大5件） → コミット						
		  > を繰り返す。						
								
								
---								
								
## クラス名でざっくり順番を書くと…								
								
1. **起動時**								
	   * `SpringBatchChunkTestApplication`（`main`）							
	   * → `BatchConfig` / `PersonImportStepConfig` などの設定クラスが読まれる							
	   * → その中の `@Bean` メソッドで							
	     `Job`, `Step`, `Reader`, `Processor`, `Writer` などが作成							
	   * → `PersonMapper` も `@MapperScan` で登録							
								
2. **ジョブ実行時（1レコードごと）**								
	   1. `FlatFileItemReader<PersonCsv>` が CSV から読む							
	   2. `PersonProcessor` が `PersonCsv` → `PersonEntity` に変換							
	   3. `MyBatisBatchItemWriter` が `PersonMapper.insert(...)` を呼んで DB に書く							
								
	この **①→②→③ の流れを、CSV の行数分だけ繰り返す**、というシーケンスです。							
								
								
								
------								
> **ジョブをキックしているのは								
「Spring Boot（Spring Batch）」で、タイミングは「アプリ起動直後」**								
です。								
								
もう少し具体的にいうと：								
								
* あなたがやっていること								
  → `main()` で								
								
  ```java								
  SpringApplication.run(SpringBatchChunkTestApplication.class, args);								
  ```								
								
  を呼んでいるだけ。								
								
* その中で Spring Boot が内部的に								
								
  1. `@Configuration` や `@Bean` から								
     `personImportJob` を見つける								
  2. `JobLauncherApplicationRunner`（Spring Boot が用意しているクラス）が								
     「登録されているジョブある？ → じゃあ実行するね」と自動で起動する								
								
なので、								
								
* **誰が**：`JobLauncherApplicationRunner`（Spring Boot の内部部品）								
* **いつ**：`SpringApplication.run(...)` でアプリが立ち上がった直後								
								
という順番で、ジョブが「勝手に」実行されます。								
								
もしこれを止めたければ、`application.properties` などで								
								
```properties								
spring.batch.job.enabled=false								
```								
								
とすると、「起動時に自動でジョブをキックしない」ようにできます。								
								
								
								
								
ChunkContext								
Stepが今どんな状態か」を持つオブジェクトであって、「Tasklet方式かChunk方式か」を選ぶ話とは 別もの です。								
								
Stepの方式（Tasklet / Chunk）								
→ 「処理の書き方」の違い								
								
ChunkContext								
→ 「今のチャンク／ステップの情報（パラメータ・実行IDなど）」を持っている入れ物								
→ Tasklet の execute や、ChunkListener から使える								
								
なので、								
「Tasklet 方式だから ChunkContext を使う」、「Chunk 方式だから ChunkContext を使う」という“どちらか”の話ではなくて、								
「Step が動いているときの状態にアクセスしたいときに使う道具が ChunkContext」								
								
								
リスナー								
イベントが起きたときに呼び出される“待ち受け役”のクラス／メソッド								
								
ジョブの開始・終了をフックしたい → JobExecutionListener								
ステップの開始・終了をフックしたい → StepExecutionListener								
チャンクの前後をフックしたい → ChunkListener								
Item 読み込み前後・エラー時をフックしたい → ItemReadListener など								
								
何が嬉しいのか								
・メインの処理（ビジネスロジック）と								
・付随する処理（ログ、監視、リトライ、通知など）								
を分離できるので、コードが見やすく・テストしやすくなります。								
								
＜超シンプルなコード例＞								
1. メイン処理（Tasklet）								
	// メインのバッチ処理（仕事本体）							
	@Component							
	public class SampleTasklet implements Tasklet {							
								
	    @Override							
	    public RepeatStatus execute(StepContribution contribution,							
	                                ChunkContext chunkContext) {							
	        System.out.println("メイン処理：実際のバッチ処理をここに書く");							
	        return RepeatStatus.FINISHED;							
	    }							
	}							
								
2. リスナー（ジョブ開始／終了のログだけ担当）								
	// ジョブ開始・終了だけを担当するリスナー							
	@Component							
	public class SampleJobListener implements JobExecutionListener {							
								
	    @Override							
	    public void beforeJob(JobExecution jobExecution) {							
	        System.out.println("リスナー：ジョブ開始");							
	    }							
								
	    @Override							
	    public void afterJob(JobExecution jobExecution) {							
	        System.out.println("リスナー：ジョブ終了");							
	    }							
	}							
								
3. Job 定義で「メイン」と「リスナー」を組み合わせる								
	@Configuration							
	public class BatchConfig {							
								
	    @Bean							
	    public Step sampleStep(JobRepository jobRepository,							
	                           PlatformTransactionManager transactionManager,							
	                           SampleTasklet tasklet) {							
	        return new StepBuilder("sampleStep", jobRepository)							
	                .tasklet(tasklet, transactionManager)							
	                .build();							
	    }							
								
	    @Bean							
	    public Job sampleJob(JobRepository jobRepository,							
	                         Step sampleStep,							
	                         SampleJobListener listener) {							
	        return new JobBuilder("sampleJob", jobRepository)							
	                .start(sampleStep)      // メイン処理							
	                .listener(listener)     // リスナーをここで「後付け」							
	                .build();							
	    }							
	}							
								
								
								
ベストプラクティス								
1 Step = 1つの意味のある処理単位								
例：掃除、コピー、集計、通知 など								
								
1 Tasklet = その Step の責務を果たすための実装								
同じ責務の範囲なら、内部で複数の小さい処理があってもOK								
								
性質の違う処理・後から別々に制御したくなる処理								
→ Step を分ける（＝Tasklet も分ける）								
								
								
バッドプラクティス								
1つの Tasklet に、								
・テーブルA→Bにコピー								
・集計結果のINSERT								
・バックアップ								
・掃除								
・メール送信								
								
…みたいに、性質の違う処理を全部詰め込むと：								
・何の Step なのか分かりづらい								
・エラーの時にどこまで終わったか分かりづらい								
・後から一部だけリトライ／スキップしたいときに困る								
ので、これは Stepを分割したほうがいい です。（1step / 1tasklet）								
